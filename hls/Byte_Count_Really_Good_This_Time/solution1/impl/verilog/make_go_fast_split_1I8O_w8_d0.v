// ==============================================================
// Generated by Vitis HLS v2023.1
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
`timescale 1ns / 1ps

module make_go_fast_split_1I8O_w8_d0
#(parameter
    PORTS                           = 8,
    DATA_WIDTH                      = 8,
    FIFO_IN_DEPTH                   = 2,
    FIFO_OUT_DEPTH                  = 0,
    STRATEGY                        = "round_robin",
    FIFO_IN_IMPL                    = "shiftreg",
    FIFO_OUT_IMPL                   = "shiftreg"
)(
    input  wire                     clk,
    input  wire                     reset,
    // input FIFO port signal group
    output wire                     if_in0_full_n,
    input  wire                     if_in0_write,
    input  wire [DATA_WIDTH-1:0]    if_in0_din,
    // output FIFO port signal group 
    output wire                     if_out0_empty_n,
    input  wire                     if_out0_read,
    output wire [DATA_WIDTH-1:0]    if_out0_dout,
    output wire                     if_out1_empty_n,
    input  wire                     if_out1_read,
    output wire [DATA_WIDTH-1:0]    if_out1_dout,
    output wire                     if_out2_empty_n,
    input  wire                     if_out2_read,
    output wire [DATA_WIDTH-1:0]    if_out2_dout,
    output wire                     if_out3_empty_n,
    input  wire                     if_out3_read,
    output wire [DATA_WIDTH-1:0]    if_out3_dout,
    output wire                     if_out4_empty_n,
    input  wire                     if_out4_read,
    output wire [DATA_WIDTH-1:0]    if_out4_dout,
    output wire                     if_out5_empty_n,
    input  wire                     if_out5_read,
    output wire [DATA_WIDTH-1:0]    if_out5_dout,
    output wire                     if_out6_empty_n,
    input  wire                     if_out6_read,
    output wire [DATA_WIDTH-1:0]    if_out6_dout,
    output wire                     if_out7_empty_n,
    input  wire                     if_out7_read,
    output wire [DATA_WIDTH-1:0]    if_out7_dout
);

//---------------Local signal-------------------
    wire [PORTS-1 : 0]              empty_n;
    wire [PORTS-1 : 0]              read;
    wire [PORTS*DATA_WIDTH-1 : 0]   dout;

    assign { if_out7_empty_n, if_out6_empty_n, if_out5_empty_n, if_out4_empty_n, if_out3_empty_n, if_out2_empty_n, if_out1_empty_n, if_out0_empty_n } = empty_n;
    assign read = { if_out7_read, if_out6_read, if_out5_read, if_out4_read, if_out3_read, if_out2_read, if_out1_read, if_out0_read };
    assign { if_out7_dout, if_out6_dout, if_out5_dout, if_out4_dout, if_out3_dout, if_out2_dout, if_out1_dout, if_out0_dout } = dout;

//---------------Instantiation------------------
    make_go_fast_split_1I8O_w8_d0_channel #(
        .PORTS          (PORTS),
        .DATA_WIDTH     (DATA_WIDTH),
        .FIFO_IN_DEPTH  (FIFO_IN_DEPTH),
        .FIFO_OUT_DEPTH (FIFO_OUT_DEPTH),
        .STRATEGY       (STRATEGY),
        .FIFO_IN_IMPL   (FIFO_IN_IMPL),
        .FIFO_OUT_IMPL  (FIFO_OUT_IMPL))
    channel_inst(
        .clk            (clk),
        .reset          (reset),
        .if_full_n      (if_in0_full_n),
        .if_write       (if_in0_write),
        .if_din         (if_in0_din),
        .if_empty_n     (empty_n),
        .if_read        (read),
        .if_dout        (dout)
    );

endmodule

module make_go_fast_split_1I8O_w8_d0_channel
#(parameter
    PORTS            = 4,
    DATA_WIDTH       = 32,
    FIFO_IN_DEPTH    = 8,
    FIFO_OUT_DEPTH   = 8,
    STRATEGY         = "load_balance", // load_balance, round_robin
    FIFO_IN_IMPL     = "shiftreg",
    FIFO_OUT_IMPL    = "shiftreg"
)(
    input  wire                          clk,
    input  wire                          reset,
    output wire                          if_full_n,
    input  wire                          if_write,
    input  wire [DATA_WIDTH-1 : 0]       if_din,
    output wire [PORTS-1 : 0]            if_empty_n,
    input  wire [PORTS-1 : 0]            if_read,
    output wire [PORTS*DATA_WIDTH-1 : 0] if_dout
);
//------------------------Parameter---------------------
    localparam PORTS_WIDTH = log2(PORTS);
//------------------------Task and function-------------
    function integer log2;
        input integer x;
        integer n, m;
    begin
        n = 0;
        m = 1;
        while (m < x) begin
            n = n + 1;
            m = m * 2;
        end
        log2 = n;
    end
    endfunction
//---------------Local signal-------------------

    wire [DATA_WIDTH-1 : 0] payload;
    wire ready, valid;

    wire [PORTS-1 : 0] req, gnt;

//---------------Instantiation------------------

    generate 
        if (FIFO_IN_DEPTH == 0) begin
            make_go_fast_split_1I8O_w8_d0_regslice #(
                .DATA_WIDTH  (DATA_WIDTH))
            rs_in (
                .clk         (clk),
                .reset       (reset),
                .s_ready     (if_full_n),
                .s_valid     (if_write),
                .s_data      (if_din),
                .m_ready     (ready),
                .m_valid     (valid),
                .m_data      (payload)
            );
        end else begin
            make_go_fast_split_1I8O_w8_d0_fifo #(
                .MEM_STYLE   (FIFO_IN_IMPL),
                .DATA_WIDTH  (DATA_WIDTH),
                .ADDR_WIDTH  (log2(FIFO_IN_DEPTH)),
                .DEPTH       (FIFO_IN_DEPTH)) 
            fifo_in (
                .clk         (clk),
                .reset       (reset),
                .if_full_n   (if_full_n),
                .if_write_ce (1'b1),
                .if_write    (if_write),
                .if_din      (if_din),
                .if_empty_n  (valid),
                .if_read_ce  (1'b1),
                .if_read     (ready),
                .if_dout     (payload)
            );
        end
    endgenerate

    make_go_fast_split_1I8O_w8_d0_arbiter #(
        .STRATEGY    (STRATEGY),
        .PORTS       (PORTS),
        .PORTS_WIDTH (PORTS_WIDTH)
    ) arbiter_inst (
        .clk         (clk),
        .reset       (reset),
        .s_ready     (ready),
        .s_valid     (valid),
        .m_ready     (req),
        .m_valid     (gnt)
    );

    genvar i;
    generate
    for (i = 0 ; i < PORTS ; i = i + 1) begin : multiple_output_loop
        if (FIFO_OUT_DEPTH == 0) begin
            make_go_fast_split_1I8O_w8_d0_regslice #(
                .DATA_WIDTH  (DATA_WIDTH))
            rs_out (
                .clk         (clk),
                .reset       (reset),
                .s_ready     (req[i]),
                .s_valid     (gnt[i]),
                .s_data      (payload),
                .m_ready     (if_read[i]),
                .m_valid     (if_empty_n[i]),
                .m_data      (if_dout[DATA_WIDTH*i +: DATA_WIDTH])
            );
        end else begin
            make_go_fast_split_1I8O_w8_d0_fifo #(
                .MEM_STYLE   (FIFO_OUT_IMPL),
                .DATA_WIDTH  (DATA_WIDTH),
                .ADDR_WIDTH  (log2(FIFO_OUT_DEPTH)),
                .DEPTH       (FIFO_OUT_DEPTH))
            fifo_out (
                .clk         (clk),
                .reset       (reset),
                .if_full_n   (req[i]),
                .if_write_ce (1'b1),
                .if_write    (gnt[i]),
                .if_din      (payload),
                .if_empty_n  (if_empty_n[i]),
                .if_read_ce  (1'b1),
                .if_read     (if_read[i]),
                .if_dout     (if_dout[DATA_WIDTH*i +: DATA_WIDTH])
            );
        end
    end
    endgenerate

endmodule


module make_go_fast_split_1I8O_w8_d0_arbiter 
#(parameter
     STRATEGY    = "load_balance",
     PORTS_WIDTH = 2,
     PORTS       = 4
)(
     input  wire               clk,
     input  wire               reset,
     input  wire               s_valid,
     output wire               s_ready,
     input  wire [PORTS-1 : 0] m_ready,
     output wire [PORTS-1 : 0] m_valid
);
//------------------------Task and function--------------
    function  [PORTS-1 : 0] arbiter_grant;
        input [PORTS-1 : 0] req;
        input [PORTS-1 : 0] base;
        reg   [2*PORTS - 1 : 0] double_req;
        reg   [2*PORTS - 1 : 0] double_grant;

        begin
            double_req    = {req, req};
            double_grant  = double_req & ~(double_req - base);
            arbiter_grant = double_grant[PORTS-1 : 0] | double_grant[2*PORTS-1 : PORTS];
        end
    endfunction

//-----------------------Local signal-------------------
    reg  [PORTS-1 : 0] base = 1'b1;
    wire [PORTS-1 : 0] req, gnt;
//------------------------Body--------------------------
    assign m_valid = gnt;
    assign s_ready = |gnt;

    assign req = s_valid ? m_ready : 'b0;

    generate 
        if (STRATEGY == "round_robin") begin
            assign gnt = req & base;
        end
        else begin // load-balance
            assign gnt = arbiter_grant(req, base);
        end
    endgenerate

    always @(posedge clk) begin
        if (reset) 
            base <= 1;
        else if (|gnt)
            base <= { gnt[PORTS-2 : 0] , gnt[PORTS-1] }; 
    end

endmodule

module make_go_fast_split_1I8O_w8_d0_regslice
#(parameter
    DATA_WIDTH = 8   // data width
) (
    // system signals
    input  wire                  clk,
    input  wire                  reset,
    // slave side
    input  wire [DATA_WIDTH-1:0] s_data,
    input  wire                  s_valid,
    output wire                  s_ready,
    // master side
    output wire [DATA_WIDTH-1:0] m_data,
    output wire                  m_valid,
    input  wire                  m_ready
);
//------------------------Parameter----------------------
    // state
    localparam [1:0]
        ZERO = 2'b10,
        ONE  = 2'b11,
        TWO  = 2'b01;
//------------------------Local signal-------------------
    reg  [DATA_WIDTH-1:0] data_p1;
    reg  [DATA_WIDTH-1:0] data_p2;
    wire         load_p1;
    wire         load_p2;
    wire         load_p1_from_p2;
    reg          s_ready_t;
    reg  [1:0]   state;
    reg  [1:0]   next;
//------------------------Body---------------------------
    assign s_ready = s_ready_t;
    assign m_data  = data_p1;
    assign m_valid = state[0];

    assign load_p1 = (state == ZERO && s_valid) ||
                     (state == ONE && s_valid && m_ready) ||
                     (state == TWO && m_ready);
    assign load_p2 = s_valid & s_ready;
    assign load_p1_from_p2 = (state == TWO);

    // data_p1
    always @(posedge clk) begin
        if (load_p1) begin
            if (load_p1_from_p2)
                data_p1 <= data_p2;
            else
                data_p1 <= s_data;
        end
    end

    // data_p2
    always @(posedge clk) begin
        if (load_p2) data_p2 <= s_data;
    end

    // s_ready_t
    always @(posedge clk) begin
        if (reset)
            s_ready_t <= 1'b0;
        else if (state == ZERO)
            s_ready_t <= 1'b1;
        else if (state == ONE && next == TWO)
            s_ready_t <= 1'b0;
        else if (state == TWO && next == ONE)
            s_ready_t <= 1'b1;
    end

    // state
    always @(posedge clk) begin
        if (reset)
            state <= ZERO;
        else
            state <= next;
    end

    // next
    always @(*) begin
        case (state)
            ZERO:
                if (s_valid & s_ready)
                    next = ONE;
                else
                    next = ZERO;
            ONE:
                if (~s_valid & m_ready)
                    next = ZERO;
                else if (s_valid & ~m_ready)
                    next = TWO;
                else
                    next = ONE;
            TWO:
                if (m_ready)
                    next = ONE;
                else
                    next = TWO;
            default:
                next = ZERO;
        endcase
    end

endmodule

module make_go_fast_split_1I8O_w8_d0_fifo
#(parameter
    MEM_STYLE  = "shiftreg",
    DATA_WIDTH = 32,
    ADDR_WIDTH = 5,
    DEPTH      = 32
) (
    // system signal
    input  wire                  clk,
    input  wire                  reset,

    // write
    output wire                  if_full_n,
    input  wire                  if_write_ce,
    input  wire                  if_write,
    input  wire [DATA_WIDTH-1:0] if_din,

    // read
    output wire                  if_empty_n,
    input  wire                  if_read_ce,
    input  wire                  if_read,
    output wire [DATA_WIDTH-1:0] if_dout
);
//------------------------Local signal-------------------
    reg  [ADDR_WIDTH-1:0] raddr = 1'b0;
    reg  [ADDR_WIDTH:0]   mOutPtr = 1'b0;
    wire                  push;
    wire                  pop;
    reg                   full_n = 1'b1;
    reg                   empty_n = 1'b0;

//----------------------generate block-------------------
    generate
    if (MEM_STYLE == "shiftreg") begin
        make_go_fast_split_1I8O_w8_d0_srl
        #(  .DATA_WIDTH (DATA_WIDTH),
            .ADDR_WIDTH (ADDR_WIDTH),
            .DEPTH      (DEPTH))
        U_fifo_srl(
            .clk        (clk),
            .we         (push),
            .din        (if_din),
            .raddr      (raddr),
            .dout       (if_dout)
        );

        assign if_empty_n = empty_n;
        assign pop        = empty_n & if_read_ce & if_read;

        // raddr
        always @(posedge clk) begin
            if (reset == 1'b1)
                raddr <= 1'b0;
            else if (push & ~pop & empty_n)
                raddr <= raddr + 1'b1;
            else if (~push & pop && raddr != 0)
                raddr <= raddr - 1'b1;
        end

    end else begin
        reg  [ADDR_WIDTH-1:0] waddr = 1'b0;
        wire [ADDR_WIDTH-1:0] wnext;
        wire [ADDR_WIDTH-1:0] rnext;
        reg                   dout_vld = 1'b0;

        make_go_fast_split_1I8O_w8_d0_ram
        #(  .MEM_STYLE  (MEM_STYLE),
            .DATA_WIDTH (DATA_WIDTH),
            .ADDR_WIDTH (ADDR_WIDTH),
            .DEPTH      (DEPTH))
        U_fifo_ram(
            .clk        (clk),
            .reset      (reset),
            .we         (push),
            .waddr      (waddr),
            .din        (if_din),
            .raddr      (rnext),
            .rden       (pop),
            .dout       (if_dout)
        );

        assign if_empty_n = dout_vld;
        assign pop        = empty_n & if_read_ce & (if_read | ~dout_vld);

        assign wnext      = !push                ? waddr :
                            (waddr == DEPTH - 1) ? 1'b0  :
                            waddr + 1'b1;
        assign rnext      = !pop                 ? raddr :
                            (raddr == DEPTH - 1) ? 1'b0  :
                            raddr + 1'b1;

        // waddr
        always @(posedge clk) begin
            if (reset == 1'b1)
                waddr <= 1'b0;
            else
                waddr <= wnext;
        end

        // raddr
        always @(posedge clk) begin
            if (reset == 1'b1)
                raddr <= 1'b0;
            else
                raddr <= rnext;
        end

        // dout_vld
        always @(posedge clk) begin
            if (reset == 1'b1)
                dout_vld <= 1'b0;
            else if (pop)
                dout_vld <= 1'b1;
            else if (if_read_ce & if_read)
                dout_vld <= 1'b0;
        end
    end
    endgenerate

//------------------------Body---------------------------
    assign if_full_n  = full_n;
    assign push       = full_n & if_write_ce & if_write;

    // mOutPtr
    always @(posedge clk) begin
        if (reset == 1'b1)
            mOutPtr <= 'b0;
        else if (push & ~pop)
            mOutPtr <= mOutPtr + 1'b1;
        else if (~push & pop)
            mOutPtr <= mOutPtr - 1'b1;
    end

    // full_n
    always @(posedge clk) begin
        if (reset == 1'b1)
            full_n <= 1'b1;
        else if (push & ~pop)
            full_n <= (mOutPtr != DEPTH - 1);
        else if (~push & pop)
            full_n <= 1'b1;
    end

    // empty_n
    always @(posedge clk) begin
        if (reset == 1'b1)
            empty_n <= 1'b0;
        else if (push & ~pop)
            empty_n <= 1'b1;
        else if (~push & pop)
            empty_n <= (mOutPtr != 1'b1);
    end

endmodule

module make_go_fast_split_1I8O_w8_d0_srl
#(parameter
    DATA_WIDTH  = 32,
    ADDR_WIDTH  = 6,
    DEPTH       = 64
) (
    input  wire                  clk,
    input  wire                  we,
    input  wire [DATA_WIDTH-1:0] din,
    input  wire [ADDR_WIDTH-1:0] raddr,
    output wire [DATA_WIDTH-1:0] dout
);

    reg  [DATA_WIDTH-1:0] mem[0:DEPTH-1];

    integer i;
    always @(posedge clk)
    begin
        if (we) begin
            for (i = 0; i < DEPTH - 1; i = i + 1) begin
                mem[i+1] <= mem[i];
            end
            mem[0] <= din;
        end
    end

    assign dout = mem[raddr];

endmodule

module make_go_fast_split_1I8O_w8_d0_ram
#(parameter
    MEM_STYLE   = "auto",
    DATA_WIDTH  = 32,
    ADDR_WIDTH  = 6,
    DEPTH       = 64
) (
    input  wire                  clk,
    input  wire                  reset,
    input  wire                  we,
    input  wire [ADDR_WIDTH-1:0] waddr,
    input  wire [DATA_WIDTH-1:0] din,
    input  wire [ADDR_WIDTH-1:0] raddr,
    input  wire                  rden,
    output reg  [DATA_WIDTH-1:0] dout
);

    (* ram_style = MEM_STYLE, rw_addr_collision = "yes" *)
    reg  [DATA_WIDTH-1:0] mem[0:DEPTH-1];
    reg  [ADDR_WIDTH-1:0] raddr_reg;

    always @(posedge clk) begin
        if (we)
            mem[waddr] <= din;
    end

    always @(posedge clk) begin
        raddr_reg <= raddr;
    end

    always @(posedge clk) begin
        if (reset)
            dout <= 0;
        else if (rden)
            dout <= mem[raddr_reg];
    end

endmodule