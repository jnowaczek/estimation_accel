-- ==============================================================
-- Generated by Vitis HLS v2023.1
-- Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
-- Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.
-- ==============================================================
-- 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0 is
    generic (
        PORTS           : INTEGER := 8;
        DATA_WIDTH      : INTEGER := 8;
        FIFO_IN_DEPTH   : INTEGER := 2;
        FIFO_OUT_DEPTH  : INTEGER := 0;
        STRATEGY        : STRING  := "round_robin";
        FIFO_IN_IMPL    : STRING  := "shiftreg";
        FIFO_OUT_IMPL   : STRING  := "shiftreg");
    port (
        clk             : in  STD_LOGIC;
        reset           : in  STD_LOGIC;
        -- input FIFO port signal group
        if_in0_full_n   : out STD_LOGIC;
        if_in0_write    : in  STD_LOGIC;
        if_in0_din      : in  STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        -- output FIFO port signal group 
        if_out0_empty_n : out STD_LOGIC;
        if_out0_read    : in  STD_LOGIC;
        if_out0_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out1_empty_n : out STD_LOGIC;
        if_out1_read    : in  STD_LOGIC;
        if_out1_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out2_empty_n : out STD_LOGIC;
        if_out2_read    : in  STD_LOGIC;
        if_out2_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out3_empty_n : out STD_LOGIC;
        if_out3_read    : in  STD_LOGIC;
        if_out3_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out4_empty_n : out STD_LOGIC;
        if_out4_read    : in  STD_LOGIC;
        if_out4_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out5_empty_n : out STD_LOGIC;
        if_out5_read    : in  STD_LOGIC;
        if_out5_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out6_empty_n : out STD_LOGIC;
        if_out6_read    : in  STD_LOGIC;
        if_out6_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);
        if_out7_empty_n : out STD_LOGIC;
        if_out7_read    : in  STD_LOGIC;
        if_out7_dout    : out STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0)
    );
end entity make_go_fast_split_1I8O_w8_d0;

architecture behave of make_go_fast_split_1I8O_w8_d0 is

    signal empty_n  : STD_LOGIC_VECTOR(PORTS-1 downto 0);
    signal rden     : STD_LOGIC_VECTOR(PORTS-1 downto 0);
    signal dout     : STD_LOGIC_VECTOR(PORTS*DATA_WIDTH-1 downto 0);

    -- component
    component make_go_fast_split_1I8O_w8_d0_channel is
        generic (
            PORTS          : INTEGER := 4;
            DATA_WIDTH     : INTEGER := 32;
            FIFO_IN_DEPTH  : INTEGER := 8;
            FIFO_OUT_DEPTH : INTEGER := 8;
            STRATEGY       : STRING  := "load_balance";
            FIFO_IN_IMPL   : STRING  := "shiftreg";
            FIFO_OUT_IMPL  : STRING  := "shiftreg");
        port (
            clk            : in  STD_LOGIC;
            reset          : in  STD_LOGIC;
            if_full_n      : out STD_LOGIC;
            if_write       : in  STD_LOGIC;
            if_din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
            if_empty_n     : out UNSIGNED(PORTS-1 downto 0);
            if_read        : in  UNSIGNED(PORTS-1 downto 0);
            if_dout        : out UNSIGNED(PORTS*DATA_WIDTH-1 downto 0));
    end component make_go_fast_split_1I8O_w8_d0_channel;
begin
    --------------------------- begin -----------------------------------
    
    -- port mapping 
    if_out0_empty_n <= empty_n(0);
    if_out1_empty_n <= empty_n(1);
    if_out2_empty_n <= empty_n(2);
    if_out3_empty_n <= empty_n(3);
    if_out4_empty_n <= empty_n(4);
    if_out5_empty_n <= empty_n(5);
    if_out6_empty_n <= empty_n(6);
    if_out7_empty_n <= empty_n(7);
    if_out0_dout    <= dout(DATA_WIDTH*(0+1)-1 downto DATA_WIDTH*0);
    if_out1_dout    <= dout(DATA_WIDTH*(1+1)-1 downto DATA_WIDTH*1);
    if_out2_dout    <= dout(DATA_WIDTH*(2+1)-1 downto DATA_WIDTH*2);
    if_out3_dout    <= dout(DATA_WIDTH*(3+1)-1 downto DATA_WIDTH*3);
    if_out4_dout    <= dout(DATA_WIDTH*(4+1)-1 downto DATA_WIDTH*4);
    if_out5_dout    <= dout(DATA_WIDTH*(5+1)-1 downto DATA_WIDTH*5);
    if_out6_dout    <= dout(DATA_WIDTH*(6+1)-1 downto DATA_WIDTH*6);
    if_out7_dout    <= dout(DATA_WIDTH*(7+1)-1 downto DATA_WIDTH*7);
    rden <= if_out7_read & if_out6_read & if_out5_read & if_out4_read & if_out3_read & if_out2_read & if_out1_read & if_out0_read;

    -- instantiation
    channel_inst : make_go_fast_split_1I8O_w8_d0_channel
    generic map (
        PORTS          => PORTS,
        DATA_WIDTH     => DATA_WIDTH,
        FIFO_IN_DEPTH  => FIFO_IN_DEPTH,
        FIFO_OUT_DEPTH => FIFO_OUT_DEPTH,
        STRATEGY       => STRATEGY,
        FIFO_IN_IMPL   => FIFO_IN_IMPL,
        FIFO_OUT_IMPL  => FIFO_OUT_IMPL)
    port map (
        clk            => clk,
        reset          => reset,
        if_full_n      => if_in0_full_n,
        if_write       => if_in0_write,
        if_din         => UNSIGNED(if_in0_din),
        if_read        => UNSIGNED(rden),
        STD_LOGIC_VECTOR(if_empty_n) => empty_n,
        STD_LOGIC_VECTOR(if_dout)    => dout
    );
    --------------------------- end -------------------------------------
end architecture behave;


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_channel is
    generic (
        PORTS          : INTEGER := 4;
        DATA_WIDTH     : INTEGER := 32;
        FIFO_IN_DEPTH  : INTEGER := 8;
        FIFO_OUT_DEPTH : INTEGER := 8;
        STRATEGY       : STRING  := "load_balance";
        FIFO_IN_IMPL   : STRING  := "shiftreg";
        FIFO_OUT_IMPL  : STRING  := "shiftreg");
    port (
        clk            : in  STD_LOGIC;
        reset          : in  STD_LOGIC;
        if_full_n      : out STD_LOGIC;
        if_write       : in  STD_LOGIC;
        if_din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
        if_empty_n     : out UNSIGNED(PORTS-1 downto 0);
        if_read        : in  UNSIGNED(PORTS-1 downto 0);
        if_dout        : out UNSIGNED(PORTS*DATA_WIDTH-1 downto 0));
end entity make_go_fast_split_1I8O_w8_d0_channel;

architecture behave of make_go_fast_split_1I8O_w8_d0_channel is

    function log2 (x : INTEGER) return INTEGER is
        variable n, m : INTEGER;
    begin
        n := 0;
        m := 1;
        while m < x loop
            n := n + 1;
            m := m * 2;
        end loop;
        return n;
    end function log2;

    --common
    constant PORTS_WIDTH : INTEGER := log2(PORTS);

    signal  payload      : UNSIGNED(DATA_WIDTH-1 downto 0);
    signal  ready        : STD_LOGIC;
    signal  valid        : STD_LOGIC;
    signal  req          : UNSIGNED(PORTS-1 downto 0);
    signal  gnt          : UNSIGNED(PORTS-1 downto 0);

    -- component
    component make_go_fast_split_1I8O_w8_d0_fifo is
        generic (
            MEM_STYLE    : STRING  := "shiftreg";
            DATA_WIDTH   : INTEGER := 8;
            ADDR_WIDTH   : INTEGER := 4;
            DEPTH        : INTEGER := 16);
        port (
            clk          : in  STD_LOGIC;
            reset        : in  STD_LOGIC;
            if_full_n    : out STD_LOGIC;
            if_write     : in  STD_LOGIC;
            if_din       : in  UNSIGNED(DATA_WIDTH-1 downto 0);
            if_empty_n   : out STD_LOGIC;
            if_read      : in  STD_LOGIC;
            if_dout      : out UNSIGNED(DATA_WIDTH-1 downto 0));
    end component make_go_fast_split_1I8O_w8_d0_fifo;

    component make_go_fast_split_1I8O_w8_d0_regslice is
        generic (
            DATA_WIDTH   : INTEGER := 8);
        port (
            clk          : in  STD_LOGIC;
            reset        : in  STD_LOGIC;
            s_data       : in  UNSIGNED(DATA_WIDTH-1 downto 0);
            s_valid      : in  STD_LOGIC;
            s_ready      : out STD_LOGIC;
            m_data       : out UNSIGNED(DATA_WIDTH-1 downto 0);
            m_valid      : out STD_LOGIC;
            m_ready      : in  STD_LOGIC);
    end component make_go_fast_split_1I8O_w8_d0_regslice;

    component make_go_fast_split_1I8O_w8_d0_arbiter is
        generic(
            STRATEGY      : STRING := "load_balance";
            PORTS_WIDTH   : INTEGER := 2;
            PORTS         : INTEGER := 4);
        port (
            clk           : in  STD_LOGIC;
            reset         : in  STD_LOGIC;
            s_valid       : in  STD_LOGIC;
            s_ready       : out STD_LOGIC;
            m_ready       : in  UNSIGNED(PORTS-1 downto 0);
            m_valid       : out UNSIGNED(PORTS-1 downto 0));
    end component make_go_fast_split_1I8O_w8_d0_arbiter;
    
begin
    --------------------------- begin -----------------------------------
    -- Instantiation
    depth_in_0 : if (FIFO_IN_DEPTH = 0) generate
        rs_in : make_go_fast_split_1I8O_w8_d0_regslice
        generic map (
            DATA_WIDTH => DATA_WIDTH)
        port map (
            clk         => clk,
            reset       => reset,
            s_ready     => if_full_n,
            s_valid     => if_write,
            s_data      => if_din,
            m_ready     => ready,
            m_valid     => valid,
            m_data      => payload);
    end generate depth_in_0;

    depth_in_gt0 : if (FIFO_IN_DEPTH /= 0) generate
        fifo_in : make_go_fast_split_1I8O_w8_d0_fifo
        generic map (
            MEM_STYLE   => FIFO_IN_IMPL,
            DATA_WIDTH  => DATA_WIDTH,
            ADDR_WIDTH  => log2(FIFO_IN_DEPTH),
            DEPTH       => FIFO_IN_DEPTH)
        port map (
            clk         => clk,
            reset       => reset,
            if_full_n   => if_full_n,
            if_write    => if_write,
            if_din      => if_din,
            if_empty_n  => valid,
            if_read     => ready,
            if_dout     => payload);
    end generate depth_in_gt0;
    
    arbiter_inst : make_go_fast_split_1I8O_w8_d0_arbiter
    generic map (
        STRATEGY    => STRATEGY,
        PORTS       => PORTS,
        PORTS_WIDTH => PORTS_WIDTH)
    port map (
        clk         => clk,
        reset       => reset,
        s_ready     => ready,
        s_valid     => valid,
        m_ready     => req,
        m_valid     => gnt);

    multiple_output_loop : for idx in 0 to PORTS-1 generate
        depth_out_0 :if (FIFO_OUT_DEPTH = 0) generate
            rs_out : make_go_fast_split_1I8O_w8_d0_regslice
            generic map (
                DATA_WIDTH => DATA_WIDTH)
            port map (
                clk         => clk,
                reset       => reset,
                s_ready     => req(idx),
                s_valid     => gnt(idx),
                s_data      => payload,
                m_ready     => if_read(idx),
                m_valid     => if_empty_n(idx),
                m_data      => if_dout(DATA_WIDTH*(idx+1)-1 downto DATA_WIDTH*idx));
        end generate depth_out_0;

        depth_out_gt0 : if (FIFO_OUT_DEPTH /= 0) generate
            fifo_out : make_go_fast_split_1I8O_w8_d0_fifo
            generic map (
                MEM_STYLE   => FIFO_OUT_IMPL,
                DATA_WIDTH  => DATA_WIDTH,
                ADDR_WIDTH  => log2(FIFO_OUT_DEPTH),
                DEPTH       => FIFO_OUT_DEPTH)
            port map (
                clk         => clk,
                reset       => reset,
                if_full_n   => req(idx),
                if_write    => gnt(idx),
                if_din      => payload,
                if_empty_n  => if_empty_n(idx),
                if_read     => if_read(idx),
                if_dout     => if_dout(DATA_WIDTH*(idx+1)-1 downto DATA_WIDTH*idx));
        end generate depth_out_gt0;
    end generate multiple_output_loop;

    --------------------------- end -------------------------------------
end architecture behave;


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_arbiter is
    generic(
        STRATEGY      : STRING := "load_balance";
        PORTS_WIDTH   : INTEGER := 2;
        PORTS         : INTEGER := 4);
    port (
        clk           : in  STD_LOGIC;
        reset         : in  STD_LOGIC;
        s_valid       : in  STD_LOGIC;
        s_ready       : out STD_LOGIC;
        m_ready       : in  UNSIGNED(PORTS-1 downto 0);
        m_valid       : out UNSIGNED(PORTS-1 downto 0));
end entity make_go_fast_split_1I8O_w8_d0_arbiter;

architecture behave of make_go_fast_split_1I8O_w8_d0_arbiter is
    function or_reduce(a : UNSIGNED(PORTS-1 downto 0)) return STD_LOGIC is
        variable ret : STD_LOGIC := '0';
    begin
        for i in a'range loop
            ret := ret or a(i);
        end loop;
    
        return ret;
    end function or_reduce;

    function arbiter_grant(req  : UNSIGNED(PORTS-1 downto 0);
                           base : UNSIGNED(PORTS-1 downto 0)) return UNSIGNED is
        variable req_buff : UNSIGNED(2*PORTS-1 downto 0);
        variable gnt_buff : UNSIGNED(2*PORTS-1 downto 0);
        variable gnt : UNSIGNED(PORTS-1 downto 0);
    begin
        req_buff := req & req;
        gnt_buff := req_buff AND (not(req_buff - base));
        gnt := gnt_buff(2*PORTS-1 downto PORTS) OR gnt_buff(PORTS-1 downto 0);

        return gnt;
    end function arbiter_grant;

    signal base  : UNSIGNED(PORTS-1 downto 0) := TO_UNSIGNED(1, PORTS);
    signal req   : UNSIGNED(PORTS-1 downto 0);
    signal gnt   : UNSIGNED(PORTS-1 downto 0);
begin
    m_valid  <= gnt;
    s_ready  <= or_reduce(gnt);

    req      <= m_ready when s_valid = '1' else (others=>'0');

    process ( clk )
    begin
        if (clk'event and clk = '1') then
            if (reset = '1') then
                base <= TO_UNSIGNED(1, PORTS);
            elsif (or_reduce(gnt) = '1') then
                base <= gnt(PORTS-2 downto 0) & gnt(PORTS-1);
            end if;
        end if;
    end process;

    round_robin_gen : if (STRATEGY = "round_robin") generate
        gnt <= req AND base;
    end generate round_robin_gen;

    load_balance_gen : if (STRATEGY /= "round_robin") generate
        gnt <= arbiter_grant(req, base);
    end generate load_balance_gen;

end architecture behave;


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_regslice is
    generic (
        DATA_WIDTH  : INTEGER := 8);
    port (
        -- system signals
        clk        : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        -- slave side
        s_data      : in  UNSIGNED(DATA_WIDTH-1 downto 0);
        s_valid     : in  STD_LOGIC;
        s_ready     : out STD_LOGIC;
        -- master side
        m_data      : out UNSIGNED(DATA_WIDTH-1 downto 0);
        m_valid     : out STD_LOGIC;
        m_ready     : in  STD_LOGIC);
end entity make_go_fast_split_1I8O_w8_d0_regslice;

architecture behave of make_go_fast_split_1I8O_w8_d0_regslice is
    constant ZERO                     : UNSIGNED(1 downto 0) := "10";
    constant ONE                      : UNSIGNED(1 downto 0) := "11";
    constant TWO                      : UNSIGNED(1 downto 0) := "01";
    signal   data_p1                  : UNSIGNED(DATA_WIDTH-1 downto 0);
    signal   data_p2                  : UNSIGNED(DATA_WIDTH-1 downto 0);
    signal   load_p1                  : STD_LOGIC;
    signal   load_p2                  : STD_LOGIC;
    signal   load_p1_from_p2          : STD_LOGIC;
    signal   s_ready_t                : STD_LOGIC;
    signal   state                    : UNSIGNED(1 downto 0);
    signal   next_st                  : UNSIGNED(1 downto 0);
begin
    s_ready <= s_ready_t;
    m_data  <= data_p1;
    m_valid <= state(0);

    load_p1 <= '1' when (state = ZERO and s_valid = '1') or
                        (state = ONE  and s_valid = '1' and m_ready = '1') or
                        (state = TWO  and m_ready = '1')
               else '0';

    load_p2         <= s_valid and s_ready_t;
    load_p1_from_p2 <= '1' when state = TWO else '0';

    data_p1_proc : process (clk)
    begin
        if (clk'event and clk = '1') then
            if (load_p1 = '1') then
                if (load_p1_from_p2 = '1') then
                    data_p1 <= data_p2;
                else
                    data_p1 <= s_data;
                end if;
            end if;
        end if;
    end process;

    data_p2_proc : process (clk)
    begin
        if (clk'event and clk = '1') then
            if (load_p2 = '1') then
                data_p2 <= s_data;
            end if;
        end if;
    end process;

    s_ready_t_proc : process (clk)
    begin
        if (clk'event and clk = '1') then
            if (reset = '1') then
                s_ready_t <= '0';
            elsif (state = ZERO) then
                s_ready_t <= '1';
            elsif (state = ONE and next_st = TWO) then
                s_ready_t <= '0';
            elsif (state = TWO and next_st = ONE) then
                s_ready_t <= '1';
            end if;
        end if;
    end process;

    state_proc : process (clk)
    begin
        if (clk'event and clk = '1') then
            if (reset = '1') then
                state <= ZERO;
            else
                state <= next_st;
            end if;
        end if;
    end process;

    next_st_proc : process (state, s_valid, s_ready_t, m_ready)
    begin
        case state is
            when ZERO =>
                if (s_valid = '1' and s_ready_t = '1') then
                    next_st <= ONE;
                else
                    next_st <= ZERO;
                end if;
            when ONE =>
                if (s_valid = '0' and m_ready = '1') then
                    next_st <= ZERO;
                elsif (s_valid = '1' and m_ready = '0') then
                    next_st <= TWO;
                else
                    next_st <= ONE;
                end if;
            when TWO =>
                if (m_ready = '1') then
                    next_st <= ONE;
                else
                    next_st <= TWO;
                end if;
            when others =>
                next_st <= ZERO;
        end case;
    end process;

end architecture behave;


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_fifo is
    generic (
        MEM_STYLE         : STRING  := "shiftreg";
        DATA_WIDTH        : INTEGER := 32;
        ADDR_WIDTH        : INTEGER := 5;
        DEPTH             : INTEGER := 32);
    port (
        clk               : in  STD_LOGIC;
        reset             : in  STD_LOGIC;
        if_full_n         : out STD_LOGIC;
        if_write          : in  STD_LOGIC;
        if_din            : in  UNSIGNED(DATA_WIDTH-1 downto 0);
        if_empty_n        : out STD_LOGIC;
        if_read           : in  STD_LOGIC;
        if_dout           : out UNSIGNED(DATA_WIDTH-1 downto 0);
        if_num_data_valid : out UNSIGNED(ADDR_WIDTH downto 0));
end entity make_go_fast_split_1I8O_w8_d0_fifo;

architecture behave of make_go_fast_split_1I8O_w8_d0_fifo is
    signal push       : STD_LOGIC;
    signal pop        : STD_LOGIC;
    signal full_n     : STD_LOGIC := '1';
    signal empty_n    : STD_LOGIC := '0';
    signal raddr      : UNSIGNED(ADDR_WIDTH-1 downto 0) := (others => '0');
    signal mOutPtr    : UNSIGNED(ADDR_WIDTH   downto 0) := (others => '0');
begin
    
    if_full_n  <= full_n;
    push       <= full_n and if_write;

    -- mOutPtr
    process (clk) begin
        if clk'event and clk = '1' then
            if reset = '1' then
                mOutPtr <= (others => '0');
            elsif push = '1' and pop = '0' then
                mOutPtr <= mOutPtr + 1;
            elsif push = '0' and pop = '1' then
                mOutPtr <= mOutPtr - 1;
            end if;
        end if;
    end process;

    -- full_n
    process (clk) begin
        if clk'event and clk = '1' then
            if reset = '1' then
                full_n <= '1';
            elsif push = '1' and pop = '0' then
                if mOutPtr = DEPTH - 1 then
                    full_n <= '0';
                else
                    full_n <= '1';
                end if;
            elsif push = '0' and pop = '1' then
                full_n <= '1';
            end if;
        end if;
    end process;

    -- empty_n
    process (clk) begin
        if clk'event and clk = '1' then
            if reset = '1' then
                empty_n <= '0';
            elsif push = '1' and pop = '0' then
                empty_n <= '1';
            elsif push = '0' and pop = '1' then
                if mOutPtr = 1 then
                    empty_n <= '0';
                else
                    empty_n <= '1';
                end if;
            end if;
        end if;
    end process;

    fifo_srl_gen: if ((MEM_STYLE = "shiftreg")) generate
        component make_go_fast_split_1I8O_w8_d0_srl is
            generic (
                DATA_WIDTH  : integer := 32;
                ADDR_WIDTH  : integer := 6;
                DEPTH       : integer := 64);
            port (
                clk         : in  STD_LOGIC;
                reset       : in  STD_LOGIC;
                we          : in  STD_LOGIC;
                din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
                raddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
                dout        : out UNSIGNED(DATA_WIDTH-1 downto 0));
        end component;
    begin
        U_ffo_srl: make_go_fast_split_1I8O_w8_d0_srl
        generic map (
            DATA_WIDTH  => DATA_WIDTH,
            ADDR_WIDTH  => ADDR_WIDTH,
            DEPTH       => DEPTH)
        port map (
            clk         => clk,
            reset       => reset,
            we          => push,
            din         => if_din,
            raddr       => raddr,
            dout        => if_dout);

        
        if_empty_n <= empty_n;
        pop        <= empty_n and if_read;

        -- raddr
        process (clk) begin
            if clk'event and clk = '1' then
                if reset = '1' then
                    raddr <= (others => '0');
                elsif (push = '1' and pop = '0' and empty_n = '1') then
                    raddr <= raddr + 1;
                elsif (push = '0' and pop = '1' and raddr /= 0) then
                    raddr <= raddr - 1;
                end if;
            end if;
        end process;
    end generate;

    -- mem based fifo
    fifo_mem_gen: if (MEM_STYLE /= "shiftreg") generate
        component make_go_fast_split_1I8O_w8_d0_ram is
            generic (
                MEM_STYLE   : string  := "auto";
                DATA_WIDTH  : integer := 32;
                ADDR_WIDTH  : integer := 6;
                DEPTH       : integer := 64);
            port (
                clk         : in  STD_LOGIC;
                reset       : in  STD_LOGIC;
                we          : in  STD_LOGIC;
                waddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
                din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
                rden        : in  STD_LOGIC;
                raddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
                dout        : out UNSIGNED(DATA_WIDTH-1 downto 0));
        end component;
        

        signal dout_vld   : STD_LOGIC := '0';
        signal waddr      : UNSIGNED(ADDR_WIDTH - 1 downto 0) := (others => '0');
        signal wnext      : UNSIGNED(ADDR_WIDTH - 1 downto 0);
        signal rnext      : UNSIGNED(ADDR_WIDTH - 1 downto 0);
    begin
        U_ffo_ram: make_go_fast_split_1I8O_w8_d0_ram
        generic map (
            MEM_STYLE   => MEM_STYLE,
            DATA_WIDTH  => DATA_WIDTH,
            ADDR_WIDTH  => ADDR_WIDTH,
            DEPTH       => DEPTH)
        port map (
            clk         => clk,
            reset       => reset,
            we          => push,
            waddr       => waddr,
            din         => if_din,
            rden        => pop,
            raddr       => rnext,
            dout        => if_dout);

        
        if_empty_n <= dout_vld;
        pop        <= empty_n and (not dout_vld or if_read);

        wnext <= waddr           when push = '0'        else
                 (others => '0') when waddr = DEPTH - 1 else
                 waddr + 1;
        rnext <= raddr           when pop = '0'         else
                 (others => '0') when raddr = DEPTH - 1 else
                 raddr + 1;

        -- waddr
        process (clk) begin
            if clk'event and clk = '1' then
                if reset = '1' then
                    waddr <= (others => '0');
                else
                    waddr <= wnext;
                end if;
            end if;
        end process;

        -- raddr
        process (clk) begin
            if clk'event and clk = '1' then
                if reset = '1' then
                    raddr <= (others => '0');
                else
                    raddr <= rnext;
                end if;
            end if;
        end process;

        -- dout_vld
        process (clk) begin
            if clk'event and clk = '1' then
                if reset = '1' then
                    dout_vld <= '0';
                elsif pop = '1' then
                    dout_vld <= '1';
                elsif if_read = '1' then
                    dout_vld <= '0';
                end if;
            end if;
        end process;
    end generate;

end architecture behave;


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_srl is
    generic (
        DATA_WIDTH  : integer := 32;
        ADDR_WIDTH  : integer := 6;
        DEPTH       : integer := 64);
    port (
        clk         : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        we          : in  STD_LOGIC;
        din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
        raddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
        dout        : out UNSIGNED(DATA_WIDTH-1 downto 0));
end make_go_fast_split_1I8O_w8_d0_srl;

architecture behav of make_go_fast_split_1I8O_w8_d0_srl is

    type SRL_ARRAY is array (0 to DEPTH-1) of UNSIGNED(DATA_WIDTH-1 downto 0);
    signal mem : SRL_ARRAY;

begin

    process (clk)
    begin
        if (clk'event and clk = '1') then
            if  we = '1' then
                for i in 0 to DEPTH - 2 loop
                    mem(i+1) <= mem(i);
                end loop;
                mem(0) <= din;
            end if;
        end  if;
    end process;

    dout <= mem(to_integer(raddr));

end architecture behav;

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity make_go_fast_split_1I8O_w8_d0_ram is
    generic (
        MEM_STYLE   : string  := "auto";
        DATA_WIDTH  : integer := 32;
        ADDR_WIDTH  : integer := 6;
        DEPTH       : integer := 64);
    port (
        clk         : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        we          : in  STD_LOGIC;
        waddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
        din         : in  UNSIGNED(DATA_WIDTH-1 downto 0);
        raddr       : in  UNSIGNED(ADDR_WIDTH-1 downto 0);
        rden        : in  STD_LOGIC;
        dout        : out UNSIGNED(DATA_WIDTH-1 downto 0));
end make_go_fast_split_1I8O_w8_d0_ram;

architecture behav of make_go_fast_split_1I8O_w8_d0_ram is

    signal raddr_reg : UNSIGNED(ADDR_WIDTH - 1 downto 0) := (others => '0');
    -- depth must be larger than 1
    type MEM_ARRAY is array (0 to DEPTH - 1) of UNSIGNED(DATA_WIDTH - 1 downto 0);
    signal mem : MEM_ARRAY;
    -- read write collision attribute settings.
    attribute ram_style: string;
    attribute ram_style of mem: signal is MEM_STYLE;
    attribute rw_addr_collision : string;
    attribute rw_addr_collision of mem : signal is "yes";

begin

    process (clk) begin
        if clk'event and clk = '1' then
            raddr_reg <= raddr;
        end if;
    end process;

    process (clk) begin
        if clk'event and clk = '1' then
            if reset = '1' then
                dout <= ( others=> '0');
            elsif (rden = '1') then
                dout <= mem(to_integer(raddr_reg));
            end if;
        end if;
    end process;

    process (clk) begin
        if clk'event and clk = '1' then
            if  we = '1' then
                mem(to_integer(waddr)) <= din;
            end if;
        end if;
    end process;
end architecture behav;
